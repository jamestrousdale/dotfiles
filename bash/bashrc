# If not running interactively, don't do anything
[[ $- != *i* ]] && return

# Load per-machine local overrides (secrets, env vars) if present
# Keep this file outside the repo (e.g. ~/.bashrc.local) and set permissions to 600
if [ -f "$HOME/.bashrc.local" ]; then
  # be conservative about world-readable secrets
  if [ -r "$HOME/.bashrc.local" ]; then
    # shellcheck disable=SC1090
    source "$HOME/.bashrc.local"
  fi
fi

# Git completion (macOS + Linux/WSL)
__dotfiles_source_first_readable() {
  local candidate
  for candidate in "$@"; do
    if [ -r "$candidate" ]; then
      # shellcheck disable=SC1090
      source "$candidate"
      return 0
    fi
  done
  return 1
}

__dotfiles_load_git_completion() {
  type __git_complete >/dev/null 2>&1 && return 0

  local bashrc_dir git_exec_path
  bashrc_dir="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
  git_exec_path="$(command -v git >/dev/null 2>&1 && git --exec-path 2>/dev/null || true)"

  local candidates=(
    "/usr/share/bash-completion/completions/git" \
    "/usr/share/git/completion/git-completion.bash" \
    "/usr/local/share/git/completion/git-completion.bash" \
    "/Library/Developer/CommandLineTools/usr/share/git-core/git-completion.bash" \
    "$bashrc_dir/completions/git-completion.bash"
  )

  if [ -n "$git_exec_path" ]; then
    candidates+=(
      "${git_exec_path%/libexec/git-core}/share/git-core/git-completion.bash"
      "${git_exec_path%/lib/git-core}/share/git-core/git-completion.bash"
      "${git_exec_path%/libexec/git-core}/share/git/completion/git-completion.bash"
      "${git_exec_path%/lib/git-core}/share/git/completion/git-completion.bash"
    )
  fi

  __dotfiles_source_first_readable "${candidates[@]}"
}

shopt -s progcomp 2>/dev/null || true
__dotfiles_load_git_completion
unset -f __dotfiles_load_git_completion __dotfiles_source_first_readable

# Set completion for make targets
complete -W "\`grep -oE '^[a-zA-Z0-9_.-]+:([^=]|$)' ?akefile | sed 's/[^a-zA-Z0-9_.-]*$//'\`" make

# Mise shims
eval "$(mise activate bash)"

# poethepoet completion
_poetry_poe_complete() {
    if command -v poe >/dev/null; then
        if [[ -z "$_POE_COMPLETION_LOADED" ]]; then
            eval "$(poe _bash_completion)"
            _POE_COMPLETION_LOADED=1
        fi
    fi
}
PROMPT_COMMAND="_poetry_poe_complete; $PROMPT_COMMAND"

##### History settings #####
# Big history
export HISTSIZE=50000
export HISTFILESIZE=100000

# Don't record duplicate lines; wipe older duplicates
export HISTCONTROL=ignoredups:erasedups

# Don't bother storing these trivial commands
export HISTIGNORE="ls:cd:pwd:clear:exit"

# Append to history instead of overwriting
shopt -s histappend

# Write to $HISTFILE after each command, and reload new lines
PROMPT_COMMAND='history -a; history -n; '"$PROMPT_COMMAND"

# Up/down arrow = search by prefix (type 'git' then press â†‘)
bind '"\e[A": history-search-backward'
bind '"\e[B": history-search-forward'

# Initialize starship prompt
eval "$(starship init bash)"

##### QoL Aliases #####
alias ll='ls -lah'
alias la='ls -A'
alias ..='cd ..'
alias ...='cd ../..'

# Python
alias py='python3'
alias venv='python3 -m venv .venv && source .venv/bin/activate'

# Git
alias gs='git status'
alias gl='git log --oneline --graph --decorate'
alias gd='git diff'
alias gc='git commit'
alias gco='git checkout'

# Kubernetes (if you use it)
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get svc'

# Clear really clears...
clear() {
    # Clear
    command clear
    # Clear scrollback buffer
    printf "\e[3J"
}

# Bind Ctrl+L to the enhanced clear function
bind '"\C-l":"clear\n"'
